<!DOCTYPE html>
<html>

  <head>

    <meta charset="UTF-8">

    <title>Showboat MP3 Player</title>

    <link rel="stylesheet" type="text/css" href="assets/css/style.css">

    <script src="assets/js/three.min.js"></script>
    <script src="assets/js/Projector.js"></script>
    <script src="assets/js/CanvasRenderer.js"></script>

  </head>

  <body>

    <audio id="player">
      <source type="audio/mp3">
    </audio>

    <script>

      const fs = require('fs')
      let mp3 = [], configString, config, files
      const configFilePath = 'showboat.config'
      if (fs.existsSync( configFilePath )) {
        configString = fs.readFileSync( configFilePath, 'utf8')
        config = JSON.parse(configString)
        files = fs.readdirSync(config.musicPath)
        files.forEach( ( file ) => {
            if ( file.slice(-3) == 'mp3') { mp3.push(file) }
        })
      }
      let ctx = new AudioContext()
      let audioSrc = ctx.createMediaElementSource(player)
      let analyser = ctx.createAnalyser()
      audioSrc.connect(analyser)
      audioSrc.connect(ctx.destination)
      let frequencyData = new Uint8Array(analyser.frequencyBinCount)
      analyser.getByteFrequencyData(frequencyData)

      const spacing = 300, side = Math.sqrt( mp3.length ), z = 350
      const midpoint = ( side * spacing ) / 2
      let container, pressed, camera, scene, renderer
      let raycaster, mouse, moved
      let objects = [], sprites = []
      let cameraReference = new THREE.Vector2( 0, 0 )

      init()
      animate()

      //---------------------------------------------------------

      function init() {

      	container = document.createElement( 'div' )
      	document.body.appendChild( container )

      	camera = new THREE.PerspectiveCamera( 70, window.innerWidth / window.innerHeight, 1, 10000 )
      	camera.position.set( midpoint, midpoint, z )

        camera.lookAt( new THREE.Vector3( midpoint, midpoint, 0) )

      	scene = new THREE.Scene()

        let geometry = new THREE.BoxGeometry( 250, 250, 10 )

        let i  = 0

        for ( let ix = 0; ix < side; ix ++ ) {
          for ( let iy = 0; iy < side; iy ++ ) {

            if ( i < mp3.length ) {

              let object = new THREE.Mesh( geometry, new THREE.MeshBasicMaterial( { opacity: 0.5 } ) )

              object.position.x = ix * spacing
              object.position.y = iy * spacing
          		scene.add( object )

              object.name = mp3[i]

          		objects.push( object )

              addText( mp3[i], ix * spacing, iy * spacing - 40, 0 )

            } else { break }

            i ++

          }
      	}

        //---------------------------------------------------------

      	raycaster = new THREE.Raycaster()
      	mouse = new THREE.Vector2()

      	renderer = new THREE.CanvasRenderer()
      	renderer.setClearColor( 0x000000 )
      	renderer.setPixelRatio( window.devicePixelRatio )
      	renderer.setSize( window.innerWidth, window.innerHeight )
      	container.appendChild( renderer.domElement )

        document.addEventListener( 'mousedown', onDocumentMouseDown, false )
        document.addEventListener( 'mouseup', onDocumentMouseUp, false )
      	document.addEventListener( 'touchstart', onDocumentTouchStart, false )
        document.addEventListener('mousemove', onDocumentMouseMove, false)

      	window.addEventListener( 'resize', onWindowResize, false )

      }

      //---------------------------------------------------------

      function addText( text, x, y, z ) {
        let canvas = document.createElement('canvas')
        let context = canvas.getContext('2d')
        context.font = "20px Arial"
        context.fillStyle = "rgba( 255, 255, 255, 0.95 )"
        context.fillText( text.substring( 0, text.length - 4 ), 0, 50, 300 )

        let texture = new THREE.Texture(canvas)
        texture.needsUpdate = true

      	let spriteMaterial = new THREE.SpriteMaterial(
      		{ map: texture } )
      	let sprite = new THREE.Sprite( spriteMaterial )
        sprite.position.set(x, y, z)
      	sprite.scale.set(250, 200, 1.0)
        sprite.name = text
      	scene.add( sprite )
        sprites.push( sprite )

      }

      //---------------------------------------------------------

      function onWindowResize() {

      	camera.aspect = window.innerWidth / window.innerHeight
      	camera.updateProjectionMatrix()
      	renderer.setSize( window.innerWidth, window.innerHeight )

      }

      //---------------------------------------------------------

      function onDocumentTouchStart( event ) {

      	event.preventDefault()

      	event.clientX = event.touches[0].clientX
      	event.clientY = event.touches[0].clientY

      	onDocumentMouseDown( event )

      }

      function onDocumentMouseDown( event ) {

        pressed = true
        moved = false

        cameraReference.x = event.clientX
        cameraReference.y = event.clientY
      }

        function onDocumentMouseUp( event ) {

          pressed = false

          if ( !moved ) {

            mouse.x = ( event.clientX / renderer.domElement.clientWidth ) * 2 - 1
          	mouse.y = - ( event.clientY / renderer.domElement.clientHeight ) * 2 + 1

          	raycaster.setFromCamera( mouse, camera )

          	let intersects = raycaster.intersectObjects( objects )

          	if ( intersects.length > 0 ) {
              if (player.paused) {

                player.src = config.musicPath + "/" + intersects[ 0 ].object.name

          		  // intersects[ 0 ].object.material.color.setHex( Math.random() * 0xffffff )

                player.play()

                sprites.forEach( ( sprite ) => {
                  sprite.visible = false
                })

              } else {

            		player.pause()

                sprites.forEach( ( sprite ) => {
                  sprite.visible = true
                })

            	}

          	}

          }

        }

        function onDocumentMouseMove( event ) {

          moved = true

          if ( pressed ) {

            if ( camera.position.x < -1000 ) {
              camera.position.x = -1000
            }

            if ( camera.position.x > side * spacing + 1000 ) {
              camera.position.x = side * spacing + 1000
            }

            if ( camera.position.y < -1000 ) {
              camera.position.y = -1000
            }

            if ( camera.position.y > side * spacing + 1000  ) {
              camera.position.y = side * spacing + 1000
            }

            camera.position.x += ( cameraReference.x - event.clientX ) * 5
            camera.position.y -= ( cameraReference.y - event.clientY ) * 5

            camera.lookAt( new THREE.Vector3( midpoint, midpoint, 0) )

            cameraReference.x = event.clientX
            cameraReference.y = event.clientY

          }

        }

      //---------------------------------------------------------

      function animate() {

      	requestAnimationFrame( animate )

      	render()

      }

      function render() {

        analyser.getByteFrequencyData(frequencyData)

        let i = 0
        for ( let k = 0; k < mp3.length; k ++ ) {
          f = frequencyData[i] / 255.0
          // objects[i].material.color.setHSL(f, f, f)
          objects[k].material.color.setRGB(1, f, 0)
          if ( i < 600 ) { i ++  }
          else { i = 0 }
        }

      	renderer.render( scene, camera )

      }

      //---------------------------------------------------------

      const {remote} = require('electron')
      const {Menu, MenuItem, BrowserWindow, dialog} = remote

      let fullscreen = false, selectPath
      const menu = new Menu()
      menu.append(new MenuItem({
        label: 'Select Music Folder',
        click() {
          selectPath = dialog.showOpenDialog(BrowserWindow.getFocusedWindow(), {
              properties: ['openDirectory']
          })
          fs.writeFileSync(configFilePath, '{\"musicPath\":\"' + selectPath + '\"}', 'utf8')
          remote.getCurrentWindow().reload()
        }
      }))
      menu.append(new MenuItem({type: 'separator'}))
      menu.append(new MenuItem({
        label: 'Fullscreen',
        type: 'checkbox',
        checked: false,
        click() {
          if ( fullscreen == false ) {
            BrowserWindow.getFocusedWindow().setFullScreen(true)
            fullscreen = true }
          else {
            BrowserWindow.getFocusedWindow().setFullScreen(false)
            fullscreen = false }
        }
      }))

      window.addEventListener('contextmenu', (e) => {
        e.preventDefault()
        menu.popup(remote.getCurrentWindow())
      }, false)

    </script>

  </body>

  <script>
    // You can also require other files to run in this process
    require('./renderer.js')
  </script>

</html>
