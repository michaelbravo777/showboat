<!DOCTYPE html>
<html>

  <head>

    <meta charset="UTF-8">

    <title>Showboat MP3 Player</title>

    <link rel="stylesheet" type="text/css" href="assets/css/style.css">

    <script src="assets/js/three.min.js"></script>
    <script src="assets/js/Projector.js"></script>
    <script src="assets/js/CanvasRenderer.js"></script>

  </head>

  <body>

    <audio id="player">
      <source type="audio/mp3">
    </audio>

    <script>

      const fs = require('fs')
      let mp3 = [], configString, config, files
      const configFilePath = 'showboat.config'
      if (fs.existsSync( configFilePath )) {
        configString = fs.readFileSync( configFilePath, 'utf8')
        config = JSON.parse(configString)
        files = fs.readdirSync(config.musicPath)
        files.forEach( ( file ) => {
            if ( file.slice(-3) == 'mp3') { mp3.push(file) }
        })
      }
      let ctx = new AudioContext(),
          audioSrc = ctx.createMediaElementSource(player),
          analyser = ctx.createAnalyser()
      audioSrc.connect(analyser)
      audioSrc.connect(ctx.destination)
      let frequencyData = new Uint8Array(analyser.frequencyBinCount)
      analyser.getByteFrequencyData(frequencyData)

      const spacing = 300,
            y = 100,
            row = 64,
            col = 16,
            squareHeight = 10,
            squareWidth = 200,
            squareDepth = 200,
            lookat = new THREE.Vector3( 0, 0, mp3.length * spacing * 2)

      let container, pressed, camera, scene, renderer,
          raycaster, mouse, moved, spriteGroup, sphereGroup,
          cubes = [], sprites = [],
          cameraReference, spriteGroupReference
          // spriteGroupReference = new THREE.Vector2( 0, 0 )

      init()
      animate()

      //---------------------------------------------------------

      function init() {
      	container = document.createElement( 'div' )
      	document.body.appendChild( container )

      	camera = new THREE.PerspectiveCamera( 70, window.innerWidth / window.innerHeight, 1, 10000 )
      	camera.position.set( 0, y, -300 )

        camera.lookAt( lookat )

      	scene = new THREE.Scene()
        spriteGroup = new THREE.Object3D()
        scene.add( spriteGroup )

        for ( let i = 0; i < mp3.length; i ++ ) {

          addText( mp3[i], 0, 0, i * spacing )

      	}

        //---------------------------------------------------------

        addCubes (-200 )
        // addCubes ( 400 )

        //---------------------------------------------------------

        sphereGroup = new THREE.Object3D()
        scene.add( sphereGroup )

        addSphere()


        //---------------------------------------------------------


        // var geometry = new THREE.Geometry()
        // geometry.vertices.push(
        //
        //   new THREE.Vector3(-2000, 100, 1000 ),
        //   new THREE.Vector3( 2000, 100, 1000 )
        //
        // )
        //
        // var line = new THREE.Line( geometry, new THREE.LineBasicMaterial( { color: 0xffffff, opacity: 0.5 } ) )
				// scene.add( line )


        //---------------------------------------------------------

      	raycaster = new THREE.Raycaster()
      	mouse = new THREE.Vector2()

      	renderer = new THREE.CanvasRenderer()
      	renderer.setClearColor( 0x000000 )
      	renderer.setPixelRatio( window.devicePixelRatio )
      	renderer.setSize( window.innerWidth, window.innerHeight )
      	container.appendChild( renderer.domElement )

        document.addEventListener( 'mousedown', onDocumentMouseDown, false )
        document.addEventListener( 'mouseup', onDocumentMouseUp, false )
      	document.addEventListener( 'touchstart', onDocumentTouchStart, false )
        document.addEventListener('mousemove', onDocumentMouseMove, false)

      	window.addEventListener( 'resize', onWindowResize, false )

      }

      //---------------------------------------------------------

      function addText( text, x, y, z ) {
        let canvas = document.createElement('canvas')
        let context = canvas.getContext('2d')
        context.font = "20px Arial"
        context.fillStyle = "rgba( 255, 255, 255, 0.95 )"
        context.fillText( text.substring( 0, text.length - 4 ), 0, 50, 300 )

        let texture = new THREE.Texture(canvas)
        texture.needsUpdate = true

      	let spriteMaterial = new THREE.SpriteMaterial(
      		{ map: texture } )
      	let sprite = new THREE.Sprite( spriteMaterial )
        sprite.position.set(x, y, z)
      	sprite.scale.set(250, 200, 1.0)
        sprite.name = text
      	spriteGroup.add( sprite )
        sprites.push( sprite )

      }

      //---------------------------------------------------------

      function addCubes( y ) {
        let geometry = new THREE.BoxGeometry( squareWidth, squareHeight, squareDepth )
        var geo = new THREE.EdgesGeometry( geometry )

        for ( let iz = 0; iz < row; iz ++ ) {
          for ( let ix = -col / 2; ix < col / 2; ix ++ ) {

            var mat = new THREE.LineBasicMaterial( { color: 0xffffff, linewidth: 2 } )
            let cube = new THREE.LineSegments( geo, mat )

            cube.position.x = ix * spacing
            cube.position.y = y
            cube.position.z = iz * spacing + 500

        		scene.add( cube )

        		cubes.push( cube )

          }
        }

      }

      //---------------------------------------------------------

      function addSphere( x ) {

        var geometry = new THREE.SphereGeometry( 100 )
        var geo = new THREE.EdgesGeometry( geometry )
        var mat = new THREE.LineBasicMaterial( { color: 0xffffff, linewidth: 2 } )

        var wireframe = new THREE.LineSegments( geo, mat )
        wireframe.position.set( 100, 100, 100 )
        sphereGroup.add( wireframe )

      }

      //---------------------------------------------------------

      function onWindowResize() {

      	camera.aspect = window.innerWidth / window.innerHeight
      	camera.updateProjectionMatrix()
      	renderer.setSize( window.innerWidth, window.innerHeight )

      }

      //---------------------------------------------------------

      function onDocumentTouchStart( event ) {

      	event.preventDefault()

      	event.clientX = event.touches[0].clientX
      	event.clientY = event.touches[0].clientY

      	onDocumentMouseDown( event )

      }

      function onDocumentMouseDown( event ) {

        pressed = true
        moved = false

        cameraReference = event.clientX
        spriteGroupReference = event.clientY
      }

        function onDocumentMouseUp( event ) {

          pressed = false

          if ( !moved ) {

            mouse.x = ( event.clientX / renderer.domElement.clientWidth ) * 2 - 1
          	mouse.y = - ( event.clientY / renderer.domElement.clientHeight ) * 2 + 1

          	raycaster.setFromCamera( mouse, camera )

          	let intersects = raycaster.intersectObjects( sprites )

          	if ( intersects.length > 0 ) {
              if (player.paused) {

                player.src = config.musicPath + "/" + intersects[ 0 ].object.name

                player.play()

              } else {

            		player.pause()

                // sprites.forEach( ( sprite ) => {
                //   sprite.visible = true
                // })
                //
                // cubes.forEach( ( cube ) => {
                //   cube.visible = false
                // })

            	}

          	}

          }

        }

        function onDocumentMouseMove( event ) {

          moved = true

          if ( pressed ) {

            if ( spriteGroup.position.z > 0 ) {
              spriteGroup.position.z = - mp3.length * spacing
            }

            if ( spriteGroup.position.z < - mp3.length * spacing ) {
              spriteGroup.position.z = 0
            }

            spriteGroup.position.z += ( spriteGroupReference - event.clientY ) * 5

            // camera.rotation.z += ( cameraReference - event.clientX ) / 180
            // camera.rotation.y = event.clientY / 180
            // cameraReference = event.clientX
            sphereGroup.position.z = event.clientX
            spriteGroupReference = event.clientY

          }

        }

      //---------------------------------------------------------

      function animate() {

      	requestAnimationFrame( animate )

      	render()

      }

      function render() {

        analyser.getByteFrequencyData(frequencyData)

        i = 0;
        for ( let k = 0; k < cubes.length; k ++ ) {
          cubes[k].material.color.setRGB(1, frequencyData[i] / 255.0, 0);
          if ( i < 1023 ) { i ++  }
          else { i = 0 }
        }

      	renderer.render( scene, camera )

      }

      //---------------------------------------------------------

      const {remote} = require('electron')
      const {Menu, MenuItem, BrowserWindow, dialog} = remote

      let fullscreen = false, selectPath
      const menu = new Menu()
      menu.append(new MenuItem({
        label: 'Select Music Folder',
        click() {
          selectPath = dialog.showOpenDialog(BrowserWindow.getFocusedWindow(), {
              properties: ['openDirectory']
          })
          fs.writeFileSync(configFilePath, '{\"musicPath\":\"' + selectPath + '\"}', 'utf8')
          remote.getCurrentWindow().reload()
        }
      }))
      menu.append(new MenuItem({type: 'separator'}))
      menu.append(new MenuItem({
        label: 'Fullscreen',
        type: 'checkbox',
        checked: false,
        click() {
          if ( fullscreen == false ) {
            BrowserWindow.getFocusedWindow().setFullScreen(true)
            fullscreen = true }
          else {
            BrowserWindow.getFocusedWindow().setFullScreen(false)
            fullscreen = false }
        }
      }))

      window.addEventListener('contextmenu', (e) => {
        e.preventDefault()
        menu.popup(remote.getCurrentWindow())
      }, false)

    </script>

  </body>

  <script>
    // You can also require other files to run in this process
    require('./renderer.js')
  </script>

</html>
