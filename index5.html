
<!DOCTYPE html>
<html lang="en">
	<head>
    <title>Showboat MP3 Player</title>

    <link rel="stylesheet" type="text/css" href="assets/css/style.css">

		<meta charset="utf-8">

		<meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">

	</head>
	<body>
    <script src="assets/js/three.min.js"></script>
		<script src="assets/js/PointerLockControls.js"></script>
		<!-- <script src="assets/js/GPUParticleSystem.js"></script> -->
		<script src="assets/js/Mirror.js"></script>
		<div id="blocker">

			<div id="instructions">
				<span style="font-size:40px">Click to play</span>
				<br />
				(W, A, S, D = Move, SPACE = Jump, MOUSE = Look around)
			</div>

		</div>

		<audio id="player">
      <source type="audio/mp3">
    </audio>

		<script>

			// if ( ! Detector.webgl ) Detector.addGetWebGLMessage();

			var fs = require('fs')
			var mp3 = [], configString, config, files
			var configFilePath = 'showboat.config'
			if (fs.existsSync( configFilePath )) {
				configString = fs.readFileSync( configFilePath, 'utf8')
				config = JSON.parse(configString)
				files = fs.readdirSync(config.musicPath)
				files.forEach( ( file ) => {
						if ( file.slice(-3) == 'mp3') { mp3.push(file) }
				})
			}
			var ctx = new AudioContext(),
					audioSrc = ctx.createMediaElementSource(player),
					analyser = ctx.createAnalyser()
			audioSrc.connect(analyser)
			audioSrc.connect(ctx.destination)
			var frequencyData = new Uint8Array(analyser.frequencyBinCount)
			analyser.getByteFrequencyData(frequencyData)

  		//---------------------------------------------------------

			var camera, scene, renderer
			var geometry, material, mesh
			var controls
			var objects = []
			var sprites = []
			var raycaster
			var groundMirror
			var particleSystem
			var blocker = document.getElementById( 'blocker' )
			var instructions = document.getElementById( 'instructions' )
			var havePointerLock = 'pointerLockElement' in document || 'mozPointerLockElement' in document || 'webkitPointerLockElement' in document
			if ( havePointerLock ) {
				var element = document.body
				var pointerlockchange = function ( event ) {
					if ( document.pointerLockElement === element || document.mozPointerLockElement === element || document.webkitPointerLockElement === element ) {
						controlsEnabled = true
						controls.enabled = true
						blocker.style.display = 'none'
					} else {
						controls.enabled = false
						blocker.style.display = '-webkit-box'
						blocker.style.display = '-moz-box'
						blocker.style.display = 'box'
						instructions.style.display = ''
					}
				}
				var pointerlockerror = function ( event ) {
					instructions.style.display = ''
				}
				// Hook pointer lock state change events
				document.addEventListener( 'pointerlockchange', pointerlockchange, false )
				document.addEventListener( 'mozpointerlockchange', pointerlockchange, false )
				document.addEventListener( 'webkitpointerlockchange', pointerlockchange, false )
				document.addEventListener( 'pointerlockerror', pointerlockerror, false )
				document.addEventListener( 'mozpointerlockerror', pointerlockerror, false )
				document.addEventListener( 'webkitpointerlockerror', pointerlockerror, false )
				instructions.addEventListener( 'click', function ( event ) {
					instructions.style.display = 'none'
					// Ask the browser to lock the pointer
					element.requestPointerLock = element.requestPointerLock || element.mozRequestPointerLock || element.webkitRequestPointerLock
					if ( /Firefox/i.test( navigator.userAgent ) ) {
						var fullscreenchange = function ( event ) {
							if ( document.fullscreenElement === element || document.mozFullscreenElement === element || document.mozFullScreenElement === element ) {
								document.removeEventListener( 'fullscreenchange', fullscreenchange )
								document.removeEventListener( 'mozfullscreenchange', fullscreenchange )
								element.requestPointerLock()
							}
						}
						document.addEventListener( 'fullscreenchange', fullscreenchange, false )
						document.addEventListener( 'mozfullscreenchange', fullscreenchange, false )
						element.requestFullscreen = element.requestFullscreen || element.mozRequestFullscreen || element.mozRequestFullScreen || element.webkitRequestFullscreen
						element.requestFullscreen()
					} else {
						element.requestPointerLock()
					}
				}, false )
			} else {
				instructions.innerHTML = 'Your browser doesn\'t seem to support Pointer Lock API'
			}
			init()
			animate()
			var controlsEnabled = false
			var moveForward = false
			var moveBackward = false
			var moveLeft = false
			var moveRight = false
			var canJump = false
			var prevTime = performance.now()
			var velocity = new THREE.Vector3()
			function init() {
				camera = new THREE.PerspectiveCamera( 75, window.innerWidth / window.innerHeight, 1, 1000 )
				scene = new THREE.Scene()
				scene.fog = new THREE.Fog( 0xffffff, 0, 750 )

				// var light = new THREE.HemisphereLight( 0xeeeeff, 0x777788, 0.75 )
				// light.position.set( 0.5, 1, 0.75 )
				// scene.add( light )

				var light = new THREE.DirectionalLight( 0xffffff );
				light.position.set( 0, 1, 1 ).normalize();
				scene.add(light);

				controls = new THREE.PointerLockControls( camera )
				scene.add( controls.getObject() )
				var onKeyDown = function ( event ) {
					switch ( event.keyCode ) {
						case 38: // up
						case 87: // w
							moveForward = true
							break
						case 37: // left
						case 65: // a
							moveLeft = true
							break
						case 40: // down
						case 83: // s
							moveBackward = true
							break
						case 39: // right
						case 68: // d
							moveRight = true
							break
						case 32: // space
							if ( canJump === true ) velocity.y += 350
							canJump = false
							break
					}
				}
				var onKeyUp = function ( event ) {
					switch( event.keyCode ) {
						case 38: // up
						case 87: // w
							moveForward = false
							break
						case 37: // left
						case 65: // a
							moveLeft = false
							break
						case 40: // down
						case 83: // s
							moveBackward = false
							break
						case 39: // right
						case 68: // d
							moveRight = false
							break
					}
				}
				document.addEventListener( 'keydown', onKeyDown, false )
				document.addEventListener( 'keyup', onKeyUp, false )
				raycaster = new THREE.Raycaster( new THREE.Vector3(), new THREE.Vector3( 0, - 1, 0 ), 0, 10 )

				//---------------------------------------------------------

				geometry = new THREE.BoxGeometry( 20, 2, 20 )
				for ( var i = 0, l = geometry.faces.length; i < l; i ++ ) {
					var face = geometry.faces[ i ]
					face.vertexColors[ 0 ] = new THREE.Color().setHSL( Math.random() * 0.3 + 0.5, 0.75, Math.random() * 0.25 + 0.75 )
					face.vertexColors[ 1 ] = new THREE.Color().setHSL( Math.random() * 0.3 + 0.5, 0.75, Math.random() * 0.25 + 0.75 )
					face.vertexColors[ 2 ] = new THREE.Color().setHSL( Math.random() * 0.3 + 0.5, 0.75, Math.random() * 0.25 + 0.75 )
				}
				for ( var i = 0; i < 200; i ++ ) {
					material = new THREE.MeshPhongMaterial( { specular: 0xffffff, shading: THREE.FlatShading, vertexColors: THREE.VertexColors } )
					var mesh = new THREE.Mesh( geometry, material )
					mesh.position.x = Math.floor( Math.random() * 20 - 10 ) * 100
					mesh.position.y = Math.floor( Math.random() * 20 ) * 20 + 10
					mesh.position.z = Math.floor( Math.random() * 20 - 10 ) * 200
					scene.add( mesh )
					material.color.setHSL( Math.random() * 0.2 + 0.5, 0.75, Math.random() * 0.25 + 0.75 )
					objects.push( mesh )
				}

				//---------------------------------------------------------

				// var side = Math.sqrt(mp3.length)
				// var i = 0
				// var space = 200
				var height = 0
				// for ( var x = 0; x < side; x ++ ) {
				// 	for ( var z = 0; z < side; z ++ ) {
				// 		if ( i < mp3.length ) {
console.log(mp3.length)
				for ( var i = 0; i < mp3.length; i ++ ) {

							//
							// var geometry = new THREE.Geometry()

							// geometry.vertices.push(
							// 	new THREE.Vector3( x * space,  0, z * space ),
							// 	new THREE.Vector3( x * space + r1,  height, z * space + r2)
							// )
							//
							// var line = new THREE.Line( geometry, new THREE.LineBasicMaterial( { color: 0xffffff, opacity: 0.5 } ) )
							// scene.add( line )

							// var geometry = new THREE.EdgesGeometry( new THREE.CircleGeometry( 5, 32 ) )
							// var material = new THREE.LineBasicMaterial( { color: 0xffffff, linewidth: 2 } )
							// var circle = new THREE.LineSegments( geometry, material )
							// circle.position.set(x * space + r1, height, z * space + r2)
							// scene.add( circle );

							var x = Math.floor( Math.random() * 20 - 10 ) * 100
							var z = Math.floor( Math.random() * 20 - 10 ) * 200

			        // var geometry = new THREE.EdgesGeometry( new THREE.SphereGeometry( 15 ) )
			        // var material = new THREE.LineBasicMaterial( { color: 0xffffff, linewidth: 1 } )
			        // var sphere = new THREE.LineSegments( geometry, material )

							var geometry = new THREE.SphereGeometry( 15 );
							// var material = new THREE.MeshBasicMaterial( {color: 0xffffff} );
							var material = new THREE.MeshPhongMaterial( {color: 0xffffff} );
							var sphere = new THREE.Mesh( geometry, material );

							// sphere.position.set(x * space, height + 3, z * space)
							sphere.position.set(x, height + 3, z)
			        scene.add( sphere )

							var canvas = document.createElement('canvas')
			        var context = canvas.getContext('2d')
			        context.font = "20px Arial"
			        context.fillStyle = "rgba( 255, 255, 255, 0.95 )"
			        context.fillText( mp3[i].substring( 0, mp3[i].length - 4 ), 0, 50, 300 )

			        var texture = new THREE.Texture(canvas)
			        texture.needsUpdate = true
							texture.minFilter = THREE.LinearFilter

			      	var spriteMaterial = new THREE.SpriteMaterial(
			      		{ map: texture } )
			      	var sprite = new THREE.Sprite( spriteMaterial )
							// sprite.position.set(x * space, height, z * space)
							sprite.position.set(x, height, z)
			      	sprite.scale.set(25, 20, 1.0)
			        sprite.name = mp3[i]
			      	scene.add( sprite )
			        sprites.push( sprite )
							// i ++
					// 	}
					// }
				}

				//---------------------------------------------------------

				// particleSystem = new THREE.GPUParticleSystem({
				// 	maxParticles: 250000
				// });
				// scene.add( particleSystem);

				//
				// var particles = new THREE.Geometry;
				//
				// for (var p = 0; p < 200; p++) {
				//     var particle = new THREE.Vector3(Math.random() * 500 - 250, Math.random() * 500 - 250, Math.random() * 500 - 250);
				//     particles.vertices.push(particle)
				// }
				//
				// var particleTexture = THREE.ImageUtils.loadTexture('assets/images/smokeparticle.png');
				// var particleMaterial = new THREE.ParticleBasicMaterial({ map: particleTexture, transparent: true, size: 10 });
				// var particleSystem = new THREE.ParticleSystem(particles, particleMaterial);
				//
				// scene.add(particleSystem);


      	//---------------------------------------------------------

				renderer = new THREE.WebGLRenderer()
				renderer.setClearColor( 0x000000 )
				renderer.setPixelRatio( window.devicePixelRatio )
				renderer.setSize( window.innerWidth, window.innerHeight )
				document.body.appendChild( renderer.domElement )

				//---------------------------------------------------------

				var planeGeo = new THREE.PlaneBufferGeometry( 10000, 10000 )
				groundMirror = new THREE.Mirror( renderer, camera, { clipBias: 0.003, textureWidth: window.innerWidth, textureHeight: window.innerHeight, color: 0x777777 } )
				var mirrorMesh = new THREE.Mesh( planeGeo, groundMirror.material )
				mirrorMesh.add( groundMirror )
				mirrorMesh.rotateX( - Math.PI / 2 )
				scene.add( mirrorMesh )

				//---------------------------------------------------------

				window.addEventListener( 'resize', onWindowResize, false )
			}

			//---------------------------------------------------------

			function onWindowResize() {
				camera.aspect = window.innerWidth / window.innerHeight
				camera.updateProjectionMatrix()
				renderer.setSize( window.innerWidth, window.innerHeight )
			}

			//---------------------------------------------------------

			function animate() {

				requestAnimationFrame( animate )

				if ( controlsEnabled ) {
					raycaster.ray.origin.copy( controls.getObject().position )
					raycaster.ray.origin.y -= 10
					var intersections = raycaster.intersectObjects( objects )
					var isOnObject = intersections.length > 0
					var time = performance.now()
					var delta = ( time - prevTime ) / 1000
					velocity.x -= velocity.x * 10.0 * delta
					velocity.z -= velocity.z * 10.0 * delta
					velocity.y -= 9.8 * 100.0 * delta // 100.0 = mass
					if ( moveForward ) velocity.z -= 400.0 * delta
					if ( moveBackward ) velocity.z += 400.0 * delta
					if ( moveLeft ) velocity.x -= 400.0 * delta
					if ( moveRight ) velocity.x += 400.0 * delta
					if ( isOnObject === true ) {
						velocity.y = Math.max( 0, velocity.y )
						canJump = true
					}

					controls.getObject().translateX( velocity.x * delta )
					controls.getObject().translateY( velocity.y * delta )
					controls.getObject().translateZ( velocity.z * delta )
					if ( controls.getObject().position.y < 10 ) {
						velocity.y = 0
						controls.getObject().position.y = 10
						canJump = true
					}

					prevTime = time
				}

				groundMirror.render()
				renderer.render( scene, camera )
			}

      //---------------------------------------------------------

      var {remote} = require('electron')
      var {Menu, MenuItem, BrowserWindow, dialog} = remote

      var fullscreen = false, selectPath

      var menu = new Menu()

      menu.append(new MenuItem({
        label: 'Select Music Folder',
        click() {
          selectPath = dialog.showOpenDialog(BrowserWindow.getFocusedWindow(), {
              properties: ['openDirectory']
          })
					if ( selectPath != 'undefined' ) {
          	fs.writeFileSync(configFilePath, '{\"musicPath\":\"' + selectPath + '\"}', 'utf8')
					}
          remote.getCurrentWindow().reload()
        }
      }))
      menu.append(new MenuItem({type: 'separator'}))
      menu.append(new MenuItem({
        label: 'Fullscreen',
        type: 'checkbox',
        checked: false,
        click() {
          if ( fullscreen == false ) {
            BrowserWindow.getFocusedWindow().setFullScreen(true)
            fullscreen = true }
          else {
            BrowserWindow.getFocusedWindow().setFullScreen(false)
            fullscreen = false }
        }
      }))

      window.addEventListener('contextmenu', (e) => {
        e.preventDefault()
        menu.popup(remote.getCurrentWindow())
      }, false)

    </script>

  </body>

  <script>
    // You can also require other files to run in this process
    require('./renderer.js')
  </script>

</html>
